# -*- coding: utf-8 -*-
"""Beyblade_COLLISION_detection.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/198SISJwn60p8h-UMt8uNjTf3GRu2wmUw

#**1. Dataset preparation**
Here we are going to import all the labeled data, splitting them in train-test-vali, with whom we will train and test our YOLO neural network to detect spinning tops:
* **Single top spin detection** $\rightarrow$ **2 classes**:
  * SPINNING
  * STILL

##Google Drive & Librerie
"""

#IMPORT LIBRERIE
import os
import glob
import cv2
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt

#GOOGLE DRIVE UPLOAD
from google.colab import drive

# Unmount the drive if it's already mounted
drive.flush_and_unmount()
print('Drive unmounted')

# Now mount the drive
drive.mount('/content/drive')

"""##Caricamento dati da ***Roboflow***

"""

!pip install roboflow

from roboflow import Roboflow
rf = Roboflow(api_key="yHvfbQJl7zNmhk5aId4U")
project = rf.workspace("beyblade-djcpy").project("beyblade-dtd3d")
version = project.version(12)
dataset = version.download("yolov11")

"""#**2. Addestramento & *Fine-Tuning* con YOLO: Transfer Learning**

Il ***Transfer Learning*** *(TL)* consiste nel prendere un modello pre-addestrato su un ampio dataset e riutilizzare (o “trasferire”) parte della sua conoscenza per un compito specifico. Nel nostro caso, partiremo da un modello YOLO pre-addestrato su un grande dataset di oggetti generici (come *COCO)*, e adatteremo (***fine-tuning***) il modello per riconoscere i due stati della trottola.

Transfer Learning è particolarmente utile quando:

* Si ha un dataset relativamente piccolo o specifico (in questo caso immagini di trottole).
* Si vuole ridurre i tempi di addestramento, poiché il modello ha già appreso a riconoscere forme e caratteristiche generali degli oggetti.

##1. Installazione YOLO & Librerie
"""

!pip install ultralytics

from ultralytics import YOLO

# Configurazione del file YAML del dataset
dataset_yaml_path = "/content/Beyblade-12/data.yaml"

"""##2. Training con YOLOv8"""

# Inizializza il modello YOLO pre-addestrato sulla sola detection spin-still
#model = YOLO('yolov8n.pt')  # inizio
model = YOLO('/content/drive/MyDrive/Beyblade_Dataset/training_results/beyblade_detector/weights/last.pt')  # dopo

# prompt: metti la gpu se c'è e stampa il tipo di gpu

import tensorflow as tf

if tf.test.gpu_device_name():
  print('GPU trovata:', tf.test.gpu_device_name())
else:
  print("Nessuna GPU trovata")

#TRAINING INIZIALE
"""
results = model.train(
    data=dataset_yaml_path,
    epochs=40,
    patience=7, #interrompe training se non ci sono miglioramenti dopo 7 epoche
    batch=16,
    imgsz=640, #le immagini devono essere 640x640
    name="beyblade_detector",
    project="/content/drive/MyDrive/Beyblade_Dataset/training_results",
    pretrained=True,
    plots=True,
    mosaic=1.0,              # Usa il mosaic augmentation: Permette di combinare fino a quattro immagini insieme, il che aiuta il modello a generalizzare meglio rispetto a diverse dimensioni e posizioni degli oggetti
    scale=0.2,               # Aggiunge variazione di scala alle immagini, utile per addestrare il modello a riconoscere trottole a diverse distanze o dimensioni.
    freeze=[0, 1, 2, 3, 4]  # Congela i primi 5 blocchi di layer, concentrando l’apprendimento sugli strati più specifici e sensibili ai dettagli di movimento e posizione
)
"""

"""**Congelare i primi 5 blocchi di layer è una buona scelta, poiché permette di sfruttare le *caratteristiche* *generiche* *apprese dai primi strati di YOLO*, mantenendo il focus del fine-tuning sugli strati più avanzati, che si specializzano sui dettagli del dataset specifico (le trottole)**"""

results = model.train(
    data=dataset_yaml_path,
    epochs=50,
    #patience=7, #interrompe training se non ci sono miglioramenti dopo 7 epoche
    batch=16,
    imgsz=640, #le immagini devono essere 640x640
    name="beyblade_detector",
    project="/content/drive/MyDrive/Beyblade_Dataset/training_results_collisions",
    pretrained=True,
    plots=True,
    mosaic=1.0,              # Usa il mosaic augmentation: Permette di combinare fino a quattro immagini insieme, il che aiuta il modello a generalizzare meglio rispetto a diverse dimensioni e posizioni degli oggetti
    scale=0.2,               # Aggiunge variazione di scala alle immagini, utile per addestrare il modello a riconoscere trottole a diverse distanze o dimensioni.
    #freeze=[0, 1, 2, 3, 4]  # Congela i primi 5 blocchi di layer, concentrando l’apprendimento sugli strati più specifici e sensibili ai dettagli di movimento e posizione
)

"""#3. Test della rete

##Install *Roboflow* & inference on video
"""

!pip install roboflow

"""## *Mini_collision* videos - inference

###mini_collision1.mp4
"""

from roboflow import Roboflow

rf = Roboflow(api_key="yHvfbQJl7zNmhk5aId4U")
project = rf.workspace().project("beyblade-dtd3d")
model = project.version("11").model

job_id, signed_url, expire_time = model.predict_video(
    "/content/drive/MyDrive/Beyblade_Dataset/Codice_Preliminare/video/mini_collision1.mp4",
    fps=5,
    prediction_type="batch-video"
)

results = model.poll_until_video_results(job_id)
print(results)

"""###mini_collision2.mp4"""

from roboflow import Roboflow

rf = Roboflow(api_key="yHvfbQJl7zNmhk5aId4U")
project = rf.workspace().project("beyblade-dtd3d")
model = project.version("11").model

job_id, signed_url, expire_time = model.predict_video(
    "/content/drive/MyDrive/Beyblade_Dataset/Codice_Preliminare/video/mini_collision2.mp4",
    fps=5,
    prediction_type="batch-video"
)

results = model.poll_until_video_results(job_id)
print(results)

"""###mini_collision3.mp4"""

from roboflow import Roboflow

rf = Roboflow(api_key="yHvfbQJl7zNmhk5aId4U")
project = rf.workspace().project("beyblade-dtd3d")
model = project.version("11").model

job_id, signed_url, expire_time = model.predict_video(
    "/content/drive/MyDrive/Beyblade_Dataset/Codice_Preliminare/video/mini_collision3.mp4",
    fps=5,
    prediction_type="batch-video"
)

results = model.poll_until_video_results(job_id)
print(results)

"""###mini_collision4.mp4"""

from roboflow import Roboflow

rf = Roboflow(api_key="yHvfbQJl7zNmhk5aId4U")
project = rf.workspace().project("beyblade-dtd3d")
model = project.version("11").model

job_id, signed_url, expire_time = model.predict_video(
    "/content/drive/MyDrive/Beyblade_Dataset/Codice_Preliminare/video/mini_collision4.mp4",
    fps=5,
    prediction_type="batch-video"
)

results = model.poll_until_video_results(job_id)
print(results)

"""###mini_collision5.mp4"""

from roboflow import Roboflow

rf = Roboflow(api_key="yHvfbQJl7zNmhk5aId4U")
project = rf.workspace().project("beyblade-dtd3d")
model = project.version("11").model

job_id, signed_url, expire_time = model.predict_video(
    "/content/drive/MyDrive/Beyblade_Dataset/Codice_Preliminare/video/mini_collision5.mp4",
    fps=5,
    prediction_type="batch-video"
)

results = model.poll_until_video_results(job_id)
print(results)

"""###mini_collision6.mp4"""

from roboflow import Roboflow

rf = Roboflow(api_key="yHvfbQJl7zNmhk5aId4U")
project = rf.workspace().project("beyblade-dtd3d")
model = project.version("11").model

job_id, signed_url, expire_time = model.predict_video(
    "/content/drive/MyDrive/Beyblade_Dataset/Codice_Preliminare/video/mini_collision6.mp4",
    fps=30,
    prediction_type="batch-video"
)

results = model.poll_until_video_results(job_id)
print(results)

"""## Testing the Model"""

# Carica il modello allenato
model = YOLO('/content/drive/MyDrive/Beyblade_Dataset/training_results_collisions/beyblade_detector/weights/best.pt')

# Eseguiamo la valutazione sul set di test
val_results = model.val(data=dataset_yaml_path, split="test")

from prettytable import PrettyTable

# Intestazioni della tabella
headers = ["Classe", "Immagini", "Istanti", "Precision (P)", "Recall (R)", "mAP50", "mAP50-95"]

# Dati della tabella
data = [
    ["all", 530, 570, 0.8, 0.953, 0.877, 0.75],
    ["COLLISION", 8, 8, 0.579, 0.875, 0.701, 0.608],
    ["spin", 527, 551, 0.997, 0.984, 0.99, 0.874],
    ["still", 9, 11, 0.823, 1.0, 0.94, 0.769],
]

# Crea la tabella
table = PrettyTable()

# Aggiungi le intestazioni e i dati alla tabella
table.field_names = headers
for row in data:
    table.add_row(row)

# Imposta lo stile della tabella
table.align = "c"  # Centra il contenuto
table.border = True  # Bordo intorno alla tabella
table.hrules = 1  # Linee orizzontali tra le righe

# Stampa la tabella
print(table)

"""#**3. Inferenza su video**"""

predictions = model.predict(
    source="/content/drive/MyDrive/Beyblade_Dataset/Codice_Preliminare/video/mini_collision3.mp4",
    save=True,
    save_txt=True,
    project="/content/drive/MyDrive/Beyblade_Dataset/training_results_collisions",
    name="collision_eval"
)